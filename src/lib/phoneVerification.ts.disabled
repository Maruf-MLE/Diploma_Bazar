import { supabase } from './supabase';

export interface PhoneVerificationResponse {
  success: boolean;
  message?: string;
  error?: string;
  otp_code?: string; // Only for development
  expires_in?: number;
  attempts_remaining?: number;
}

export interface PhoneVerificationAttempt {
  id: string;
  user_id: string;
  phone_number: string;
  otp_code: string;
  attempts: number;
  verified: boolean;
  expires_at: string;
  created_at: string;
}

class PhoneVerificationService {
  /**
   * Send OTP to phone number
   */
  async sendOTP(phoneNumber: string): Promise<PhoneVerificationResponse> {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return {
          success: false,
          error: 'User not authenticated'
        };
      }

      console.log('Sending OTP to:', phoneNumber, 'for user:', user.id);

      // Clean phone number format
      const cleanedPhone = this.cleanPhoneNumber(phoneNumber);
      
      if (!this.isValidBangladeshiPhoneNumber(cleanedPhone)) {
        return {
          success: false,
          error: '‡¶Ö‡¶¨‡ßà‡¶ß ‡¶´‡ßã‡¶® ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞‡•§ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßÄ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® (‡¶Ø‡ßá‡¶Æ‡¶®: +8801XXXXXXXXX)'
        };
      }

      // Call database function to generate OTP
      const { data, error } = await supabase.rpc('generate_phone_otp', {
        p_phone_number: cleanedPhone
      });

      if (error) {
        console.error('Error creating phone verification attempt:', {
          error,
          errorMessage: error.message,
          errorCode: error.code,
          errorDetails: error.details,
          userId: user.id,
          phoneNumber: cleanedPhone
        });
        
        // Check if the error is related to missing function or table
        if (error.message?.includes('function') || error.message?.includes('does not exist')) {
          return {
            success: false,
            error: '‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶π‡¶Ø‡¶º‡¶®‡¶ø‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá admin ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®‡•§'
          };
        }
        
        return {
          success: false,
          error: `OTP ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá: ${error.message || '‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§'}`
        };
      }

      console.log('Generated OTP:', data); // Development logging
      
      // Check if we should send real SMS (controlled by environment variable)
      const shouldSendRealSMS = import.meta.env.VITE_ENABLE_SMS === 'true';
      
      console.log('üîç SMS Configuration Check:');
      console.log('   NODE_ENV:', process.env.NODE_ENV);
      console.log('   VITE_ENABLE_SMS:', import.meta.env.VITE_ENABLE_SMS);
      console.log('   shouldSendRealSMS:', shouldSendRealSMS);
      
      // Send real SMS if enabled
      if (shouldSendRealSMS) {
        try {
          console.log('üì§ Real SMS mode: Attempting to send SMS via Twilio');
          await this.sendSMSViaTwilio(cleanedPhone, data);
          console.log('‚úÖ SMS sent successfully!');
        } catch (smsError) {
          console.error('‚ùå SMS sending failed:', smsError);
          // Still show development fallback if SMS fails
          console.log('üìã Showing development OTP as fallback');
          alert(`‚ö†Ô∏è SMS Failed - Development OTP\n\nPhone: ${cleanedPhone}\nOTP Code: ${data}\n\nSMS Error: ${smsError.message}`);
        }
      } else {
        // Development mode or SMS disabled - show OTP in console and alert
        console.log('üî¢ DEVELOPMENT MODE: OTP Code =', data);
        console.log('üî¢ Use this OTP to verify:', data);
        console.log('üì± Phone Number:', cleanedPhone);
        console.log('‚ö†Ô∏è  SMS is disabled. Set VITE_ENABLE_SMS=true to enable real SMS');
        
        // Show alert in development
        alert(`üî¢ Development Mode OTP\n\nPhone: ${cleanedPhone}\nOTP Code: ${data}\n\n‚ö†Ô∏è Real SMS disabled. Check VITE_ENABLE_SMS setting`);
        
        // Also show in browser notification if supported
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification('Development OTP', {
            body: `Your OTP is: ${data}`,
            icon: '/favicon.ico'
          });
        }
      }

      return {
        success: true,
        message: 'OTP ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡ßß‡ß¶ ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡ßÅ‡¶®‡•§',
        expires_in: 10,
        // Remove OTP from response in production
        ...(process.env.NODE_ENV !== 'production' && { otp_code: data })
      };

    } catch (error) {
      console.error('Error sending OTP:', error);
      return {
        success: false,
        error: 'OTP ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§'
      };
    }
  }

  /**
   * Verify OTP code
   */
  async verifyOTP(otpCode: string): Promise<PhoneVerificationResponse> {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return {
          success: false,
          error: 'User not authenticated'
        };
      }

      console.log('Verifying OTP for user:', user.id);

      // First get user's phone number from profiles
      const { data: profile } = await supabase
        .from('profiles')
        .select('phone_number')
        .eq('id', user.id)
        .single();

      if (!profile?.phone_number) {
        return {
          success: false,
          error: '‡¶´‡ßã‡¶® ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ OTP ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§'
        };
      }

      // Call database function to verify OTP
      const { data, error } = await supabase.rpc('verify_phone_otp', {
        p_phone_number: profile.phone_number,
        p_otp_code: otpCode.trim()
      });

      if (error) {
        console.error('Error verifying OTP:', error);
        return {
          success: false,
          error: 'OTP ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§'
        };
      }

      if (data.success) {
        // Trigger profile update event
        window.dispatchEvent(new CustomEvent('phone-verified', { 
          detail: { userId: user.id } 
        }));
      }

      return data;

    } catch (error) {
      console.error('Error verifying OTP:', error);
      return {
        success: false,
        error: 'OTP ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§'
      };
    }
  }

  /**
   * Check if user's phone is verified
   */
  async getPhoneVerificationStatus(): Promise<{
    phone_verified: boolean;
    phone_number?: string;
  }> {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return { phone_verified: false };
      }

      const { data: profile, error } = await supabase
        .from('profiles')
        .select('phone_verified, phone_number')
        .eq('id', user.id)
        .single();

      if (error) {
        console.error('Error getting phone verification status:', error);
        return { phone_verified: false };
      }

      return {
        phone_verified: profile?.phone_verified || false,
        phone_number: profile?.phone_number
      };

    } catch (error) {
      console.error('Error checking phone verification status:', error);
      return { phone_verified: false };
    }
  }

  /**
   * Get current verification attempt status
   */
  async getCurrentVerificationAttempt(): Promise<PhoneVerificationAttempt | null> {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) return null;

      const { data, error } = await supabase
        .from('phone_verification_attempts')
        .select('*')
        .eq('user_id', user.id)
        .eq('verified', false)
        .gt('expires_at', new Date().toISOString())
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

      if (error && error.code !== 'PGRST116') {
        console.error('Error getting current verification attempt:', error);
        return null;
      }

      return data;

    } catch (error) {
      console.error('Error getting current verification attempt:', error);
      return null;
    }
  }

  /**
   * Clean and format phone number
   */
  private cleanPhoneNumber(phoneNumber: string): string {
    // Remove all spaces, dashes, and other non-numeric characters except +
    let cleaned = phoneNumber.replace(/[^\d+]/g, '');
    
    // Handle Bangladeshi phone number formats
    if (cleaned.startsWith('01')) {
      cleaned = '+880' + cleaned;
    } else if (cleaned.startsWith('8801')) {
      cleaned = '+' + cleaned;
    } else if (!cleaned.startsWith('+880') && cleaned.startsWith('880')) {
      cleaned = '+' + cleaned;
    }
    
    return cleaned;
  }

  /**
   * Validate Bangladeshi phone number
   */
  private isValidBangladeshiPhoneNumber(phoneNumber: string): boolean {
    // Bangladesh phone number format: +8801XXXXXXXXX (11 digits after +880)
    // Allow both +8801XXXXXXXX (10 digits) and +8801XXXXXXXXX (11 digits)
    const bangladeshiPhoneRegex = /^\+880[1-9]\d{8,9}$/;
    return bangladeshiPhoneRegex.test(phoneNumber);
  }

  /**
   * Send SMS via Direct Twilio API
   */
  private async sendSMSViaTwilio(phoneNumber: string, otpCode: string): Promise<void> {
    try {
      console.log('üì§ Sending SMS via Direct Twilio API to:', phoneNumber);
      
      // Import Twilio service dynamically
      const { twilioSMSService } = await import('./twilioSMS');
      
      // Send SMS using direct Twilio integration
      const result = await twilioSMSService.sendOTPSMS(phoneNumber, otpCode);

      if (!result.success) {
        console.error('‚ùå SMS sending failed:', result.error);
        throw new Error(result.error || 'SMS sending failed');
      }

      console.log('‚úÖ SMS sent successfully via Twilio:', result.messageSid);

    } catch (error) {
      console.error('‚ùå Error sending SMS via Twilio:', error);
      // Don't throw error here as the OTP is already saved in database
      // The user can still use the OTP even if SMS sending fails
      console.warn('‚ö†Ô∏è SMS sending failed, but OTP is still valid for verification');
      throw error; // Re-throw so caller knows SMS failed
    }
  }

  /**
   * Resend OTP (same as sendOTP but with additional validation)
   */
  async resendOTP(phoneNumber: string): Promise<PhoneVerificationResponse> {
    return this.sendOTP(phoneNumber);
  }
}

// Export singleton instance
export const phoneVerificationService = new PhoneVerificationService();

// Helper function to format phone number for display
export const formatPhoneNumberForDisplay = (phoneNumber: string): string => {
  if (!phoneNumber) return '';
  
  if (phoneNumber.startsWith('+880')) {
    const number = phoneNumber.slice(4); // Remove +880
    return `0${number.slice(0, 2)} ${number.slice(2, 5)} ${number.slice(5)}`;
  }
  
  return phoneNumber;
};

// Helper function to check if phone verification is required
export const isPhoneVerificationRequired = async (): Promise<boolean> => {
  const status = await phoneVerificationService.getPhoneVerificationStatus();
  return !status.phone_verified;
};
