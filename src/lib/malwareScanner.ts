/**
 * üõ°Ô∏è File Upload Malware Scanner & Security System
 * Comprehensive security layer for all file uploads
 */

// Magic bytes signatures for common file types
const FILE_SIGNATURES = {
  // Images
  'image/jpeg': [[0xFF, 0xD8, 0xFF]],
  'image/jpg': [[0xFF, 0xD8, 0xFF]],
  'image/png': [[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]],
  'image/gif': [[0x47, 0x49, 0x46, 0x38, 0x37, 0x61], [0x47, 0x49, 0x46, 0x38, 0x39, 0x61]],
  'image/webp': [[0x52, 0x49, 0x46, 0x46]], // Followed by WEBP
  'image/bmp': [[0x42, 0x4D]],
  'image/svg+xml': [[0x3C, 0x73, 0x76, 0x67]], // <svg
  
  // Documents
  'application/pdf': [[0x25, 0x50, 0x44, 0x46]], // %PDF
  'application/msword': [[0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1]], // DOC
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document': [[0x50, 0x4B, 0x03, 0x04]], // DOCX (ZIP)
  'text/plain': [], // Text files can start with anything
  
  // Archives
  'application/zip': [[0x50, 0x4B, 0x03, 0x04], [0x50, 0x4B, 0x05, 0x06], [0x50, 0x4B, 0x07, 0x08]],
  'application/x-rar-compressed': [[0x52, 0x61, 0x72, 0x21, 0x1A, 0x07, 0x00], [0x52, 0x61, 0x72, 0x21, 0x1A, 0x07, 0x01, 0x00]]
};

// Dangerous file extensions (case insensitive)
const DANGEROUS_EXTENSIONS = [
  'exe', 'bat', 'cmd', 'com', 'pif', 'scr', 'vbs', 'js', 'jar', 'msi', 'dll',
  'sh', 'ps1', 'php', 'asp', 'aspx', 'jsp', 'py', 'rb', 'pl', 'cgi',
  'app', 'deb', 'pkg', 'dmg', 'apk', 'ipa', 'xap'
];

// Suspicious patterns in filenames
const SUSPICIOUS_PATTERNS = [
  /\.(exe|bat|cmd|scr|vbs|js|jar)$/i,
  /\.php\./i,
  /\x00/g, // Null bytes
  /[<>:"|?*]/g, // Invalid filename characters
  /^\./,  // Hidden files starting with dot
  /\.(com|net|org|gov|mil)$/i // Domain-like extensions
];

// Malware signature patterns (hexadecimal)
const MALWARE_SIGNATURES = [
  // Common virus signatures
  '4d5a', // MZ header (PE executable)
  '7f454c46', // ELF header (Linux executable)
  'cafebabe', // Java bytecode
  'feedface', // Mach-O binary
  'cefaedfe', // Mach-O binary (reverse)
  
  // Script injection patterns
  '3c736372697074', // <script
  '6a617661736372697074', // javascript
  '6f6e6c6f6164', // onload
  '6f6e6572726f72', // onerror
  '657865632842', // exec(
  '657661642842', // eval(
  
  // PHP malicious patterns
  '3c3f706870', // <?php
  '6576616c28', // eval(
  '62617365363420', // base64 
  '7368656c6c5f65786563', // shell_exec
  '73797374656d28', // system(
  '706173737468727528', // passthru(
  
  // Embedded executables
  '504b0304', // ZIP header (can contain malware)
  '526172211a07', // RAR header
];

// Content scanning patterns
const CONTENT_PATTERNS = {
  // JavaScript injection
  javascript: [
    /<script[^>]*>.*?<\/script>/gi,
    /javascript:/gi,
    /on\w+\s*=\s*["'][^"']*["']/gi,
    /eval\s*\(/gi,
    /setTimeout\s*\(/gi,
    /setInterval\s*\(/gi
  ],
  
  // SQL injection
  sql: [
    /union\s+select/gi,
    /drop\s+table/gi,
    /delete\s+from/gi,
    /insert\s+into/gi,
    /update\s+set/gi,
    /exec\s*\(/gi,
    /xp_cmdshell/gi
  ],
  
  // Command injection
  command: [
    /;\s*(rm|del|format|shutdown)/gi,
    /\|\s*(curl|wget|nc|netcat)/gi,
    /`[^`]*`/g, // Backticks
    /\$\([^)]*\)/g, // Command substitution
  ],
  
  // HTML injection
  html: [
    /<iframe[^>]*>/gi,
    /<object[^>]*>/gi,
    /<embed[^>]*>/gi,
    /<link[^>]*>/gi,
    /<meta[^>]*http-equiv/gi
  ]
};

export interface SecurityScanResult {
  isSecure: boolean;
  threats: string[];
  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  details: string;
  allowUpload: boolean;
  sanitizedFileName?: string;
}

export interface FileValidationOptions {
  maxSize: number; // in bytes
  allowedTypes: string[];
  strictValidation: boolean;
  scanContent: boolean;
  quarantineOnThreat: boolean;
}

/**
 * üîç Check file magic bytes against its MIME type
 */
function validateFileSignature(file: File, buffer: ArrayBuffer): boolean {
  const uint8Array = new Uint8Array(buffer.slice(0, 32)); // First 32 bytes
  const signatures = FILE_SIGNATURES[file.type as keyof typeof FILE_SIGNATURES];
  
  if (!signatures || signatures.length === 0) {
    // For text files or unsupported types, we'll be lenient
    return file.type === 'text/plain' || file.type.startsWith('text/');
  }
  
  // Check if any signature matches
  return signatures.some(signature => {
    if (signature.length === 0) return true; // Empty signature means any content is valid
    
    return signature.every((byte, index) => {
      if (index >= uint8Array.length) return false;
      return uint8Array[index] === byte;
    });
  });
}

/**
 * ü¶† Scan for malware signatures in file content
 */
function scanForMalwareSignatures(buffer: ArrayBuffer): string[] {
  const threats: string[] = [];
  const bytes = new Uint8Array(buffer);
  const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
  
  // Check against known malware signatures
  MALWARE_SIGNATURES.forEach(signature => {
    if (hex.includes(signature.toLowerCase())) {
      threats.push(`Malware signature detected: ${signature}`);
    }
  });
  
  // Look for executable headers
  if (hex.startsWith('4d5a')) {
    threats.push('Executable file detected (PE/DOS header)');
  }
  
  if (hex.startsWith('7f454c46')) {
    threats.push('Linux executable detected (ELF header)');
  }
  
  return threats;
}

/**
 * üìù Scan text content for malicious patterns
 */
function scanTextContent(content: string): string[] {
  const threats: string[] = [];
  
  Object.entries(CONTENT_PATTERNS).forEach(([category, patterns]) => {
    patterns.forEach(pattern => {
      if (pattern.test(content)) {
        threats.push(`${category.toUpperCase()} injection pattern detected`);
      }
    });
  });
  
  return threats;
}

/**
 * üìÇ Validate filename for security issues
 */
function validateFileName(fileName: string): { isValid: boolean; threats: string[]; sanitized: string } {
  const threats: string[] = [];
  let sanitized = fileName;
  
  // Check for dangerous extensions
  const extension = fileName.split('.').pop()?.toLowerCase() || '';
  if (DANGEROUS_EXTENSIONS.includes(extension)) {
    threats.push(`Dangerous file extension: .${extension}`);
  }
  
  // Check for suspicious patterns
  SUSPICIOUS_PATTERNS.forEach(pattern => {
    if (pattern.test(fileName)) {
      threats.push(`Suspicious filename pattern detected`);
    }
  });
  
  // Check for double extensions
  const parts = fileName.split('.');
  if (parts.length > 2) {
    const secondExt = parts[parts.length - 2].toLowerCase();
    if (DANGEROUS_EXTENSIONS.includes(secondExt)) {
      threats.push(`Double extension detected: .${secondExt}.${extension}`);
    }
  }
  
  // Sanitize filename
  sanitized = fileName
    .replace(/[<>:"|?*\x00-\x1f]/g, '') // Remove invalid chars
    .replace(/^\.+/, '') // Remove leading dots
    .replace(/\.+$/, '') // Remove trailing dots
    .trim();
  
  // Ensure filename isn't empty after sanitization
  if (!sanitized || sanitized === extension) {
    sanitized = `safe_file_${Date.now()}.${extension}`;
  }
  
  return {
    isValid: threats.length === 0,
    threats,
    sanitized
  };
}

/**
 * üõ°Ô∏è Comprehensive file security scanner
 */
export async function scanFileForThreats(
  file: File, 
  options: FileValidationOptions = {
    maxSize: 10 * 1024 * 1024, // 10MB
    allowedTypes: ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'],
    strictValidation: true,
    scanContent: true,
    quarantineOnThreat: false
  }
): Promise<SecurityScanResult> {
  
  const threats: string[] = [];
  let riskLevel: SecurityScanResult['riskLevel'] = 'LOW';
  
  try {
    // 1. Basic file validation
    if (file.size > options.maxSize) {
      threats.push(`File size exceeds limit: ${(file.size / (1024 * 1024)).toFixed(2)}MB > ${(options.maxSize / (1024 * 1024)).toFixed(2)}MB`);
      riskLevel = 'MEDIUM';
    }
    
    if (file.size === 0) {
      threats.push('Empty file detected');
      riskLevel = 'HIGH';
    }
    
    // 2. MIME type validation (more lenient for common image formats)
    if (!options.allowedTypes.includes(file.type)) {
      // Check if it's a common image type with different MIME variations
      const commonImageVariations = {
        'image/jpg': 'image/jpeg',
        'image/jpeg': 'image/jpg',
        'image/pjpeg': 'image/jpeg' // Progressive JPEG
      };
      
      const alternativeType = commonImageVariations[file.type as keyof typeof commonImageVariations];
      
      if (!alternativeType || !options.allowedTypes.includes(alternativeType)) {
        threats.push(`File type not allowed: ${file.type}`);
        riskLevel = 'MEDIUM'; // Reduce from HIGH to MEDIUM for type mismatch
      }
    }
    
    // 3. Filename validation (more lenient for images)
    const filenameCheck = validateFileName(file.name);
    if (!filenameCheck.isValid && !file.type.startsWith('image/')) {
      threats.push(...filenameCheck.threats);
      riskLevel = 'HIGH';
    }
    
    // 4. Read file content for deep scanning
    const buffer = await file.arrayBuffer();
    
    // 5. Magic byte validation
    if (options.strictValidation && !validateFileSignature(file, buffer)) {
      threats.push(`File signature doesn't match MIME type: ${file.type}`);
      riskLevel = 'HIGH';
    }
    
    // 6. Malware signature scanning
    const malwareThreats = scanForMalwareSignatures(buffer);
    if (malwareThreats.length > 0) {
      threats.push(...malwareThreats);
      riskLevel = 'CRITICAL';
    }
    
    // 7. Content pattern scanning (for text-based files)
    if (options.scanContent && (file.type.startsWith('text/') || file.type.includes('xml') || file.type.includes('html'))) {
      try {
        const textContent = new TextDecoder('utf-8', { fatal: false }).decode(buffer);
        const contentThreats = scanTextContent(textContent);
        if (contentThreats.length > 0) {
          threats.push(...contentThreats);
          riskLevel = 'HIGH';
        }
      } catch (error) {
        // Could not decode as text, might be binary - that's okay for images
      }
    }
    
    // 8. Additional checks for images
    if (file.type.startsWith('image/')) {
      // Check for embedded scripts in SVG
      if (file.type === 'image/svg+xml') {
        try {
          const svgContent = new TextDecoder().decode(buffer);
          if (/<script/i.test(svgContent) || /javascript:/i.test(svgContent)) {
            threats.push('JavaScript detected in SVG file');
            riskLevel = 'CRITICAL';
          }
        } catch (error) {
          threats.push('Could not validate SVG content');
          riskLevel = 'MEDIUM';
        }
      }
      
      // Check for suspicious EXIF data
      const firstBytes = new Uint8Array(buffer.slice(0, 1024));
      const hex = Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join('');
      
      if (hex.includes('3c736372697074') || hex.includes('6a617661736372697074')) {
        threats.push('Suspicious script content found in image metadata');
        riskLevel = 'HIGH';
      }
    }
    
    // 9. Determine final risk level and decision
    const isSecure = threats.length === 0;
    const allowUpload = isSecure || (riskLevel !== 'CRITICAL' && riskLevel !== 'HIGH');
    
    // 10. Log security event (disabled for normal image uploads)
    if (threats.length > 0 && riskLevel === 'CRITICAL') {
      console.log('üõ°Ô∏è Security scan completed:', {
        fileName: file.name,
        fileType: file.type,
        fileSize: file.size,
        riskLevel,
        allowUpload
      });
      
      // Only show console.warn for CRITICAL threats (malware detected)
      if (riskLevel === 'CRITICAL') {
        console.warn('üö® CRITICAL THREAT DETECTED:', {
          fileName: file.name,
          fileType: file.type,
          fileSize: file.size,
          threats,
          riskLevel,
          timestamp: new Date().toISOString()
        });
      }
      // Commented out console.warn for HIGH/MEDIUM risks to avoid false positives
      // console.warn('üö® File Security Scan Results:', { ... });
      
      // Send security alert (in production, you might want to send this to your security monitoring system)
      const securityEvent = {
        type: 'FILE_UPLOAD_THREAT_DETECTED',
        fileName: file.name,
        fileType: file.type,
        threats,
        riskLevel,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href
      };
      
      // Store in localStorage for security monitoring
      const existingEvents = JSON.parse(localStorage.getItem('security_events') || '[]');
      existingEvents.push(securityEvent);
      
      // Keep only last 100 events
      if (existingEvents.length > 100) {
        existingEvents.splice(0, existingEvents.length - 100);
      }
      
      localStorage.setItem('security_events', JSON.stringify(existingEvents));
    }
    
    return {
      isSecure,
      threats,
      riskLevel,
      details: threats.length > 0 ? threats.join('; ') : 'File passed all security checks',
      allowUpload,
      sanitizedFileName: filenameCheck.sanitized
    };
    
  } catch (error) {
    console.error('Error during file security scan:', error);
    
    return {
      isSecure: false,
      threats: ['Failed to scan file for security threats'],
      riskLevel: 'MEDIUM',
      details: `Security scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      allowUpload: false
    };
  }
}

/**
 * üîí Quick security check for file uploads (lightweight version)
 */
export function quickSecurityCheck(file: File): { passed: boolean; reason?: string } {
  // Size check
  if (file.size > 50 * 1024 * 1024) { // 50MB hard limit
    return { passed: false, reason: 'File too large (max 50MB)' };
  }
  
  if (file.size === 0) {
    return { passed: false, reason: 'Empty file' };
  }
  
  // Extension check
  const extension = file.name.split('.').pop()?.toLowerCase() || '';
  if (DANGEROUS_EXTENSIONS.includes(extension)) {
    return { passed: false, reason: `Dangerous file type: .${extension}` };
  }
  
  // Basic pattern check
  if (SUSPICIOUS_PATTERNS.some(pattern => pattern.test(file.name))) {
    return { passed: false, reason: 'Suspicious filename pattern' };
  }
  
  return { passed: true };
}

/**
 * üìä Get security statistics
 */
export function getSecurityStats() {
  try {
    const events = JSON.parse(localStorage.getItem('security_events') || '[]');
    const last24h = events.filter((event: any) => 
      new Date(event.timestamp) > new Date(Date.now() - 24 * 60 * 60 * 1000)
    );
    
    return {
      totalThreatsDetected: events.length,
      threatsLast24h: last24h.length,
      riskLevels: events.reduce((acc: any, event: any) => {
        acc[event.riskLevel] = (acc[event.riskLevel] || 0) + 1;
        return acc;
      }, {}),
      commonThreats: events.reduce((acc: any, event: any) => {
        event.threats.forEach((threat: string) => {
          acc[threat] = (acc[threat] || 0) + 1;
        });
        return acc;
      }, {})
    };
  } catch (error) {
    return {
      totalThreatsDetected: 0,
      threatsLast24h: 0,
      riskLevels: {},
      commonThreats: {}
    };
  }
}
